// Code generated by gorpcgen; DO NOT EDIT.

package {{ $.ServerPackage }}

import (
	"context"
	"encoding/json"
	"fmt"
	"sync"
	"time"

	coreErrors "github.com/andrskom/gorpcgen/protocol/errors"
	coreModels "github.com/andrskom/gorpcgen/protocol/models"
	coreCtx "github.com/andrskom/gorpcgen/protocol/context"
	"github.com/sirupsen/logrus"
	"github.com/nats-io/go-nats"
	serverHandlers "{{ $.HandlersPackage }}"
	{{- if $.UseValidation }}
	"github.com/xeipuuv/gojsonschema"
	{{- end }}
)

type HandlersInterface interface {
	{{range $method := .Methods -}}
	{{ $method.Name }}(coreModels.RequestMeta, *serverHandlers.{{ $method.RequestName }}) (serverHandlers.{{ $method.ResponseName }}, *coreErrors.Error)
	{{- end}}
}

type MetricsInterface interface {
	APIDurationFunc(string, string, func() (respType coreModels.ResponseType))
}

type Server struct {
	logger          *logrus.Entry
	nc              *nats.Conn
	ctx             context.Context
	cancelFunc      context.CancelFunc
	shutdownTimeout time.Duration
	shutdownChan    chan bool
	runningWG       sync.WaitGroup
	handlers        *serverHandlers.{{ $.ServiceName }}
	metrics         MetricsInterface
	{{if $.UseValidation -}}
	validators      *Validators
	{{- end }}
}

func NewServer(
	ctx context.Context,
	logger *logrus.Entry,
	nc *nats.Conn,
	handlers *serverHandlers.{{ $.ServiceName }},
	metrics MetricsInterface,
	{{if $.UseValidation -}}
	validators *Validators,
	{{- end }}
) *Server {
	s := &Server{
		logger:          logger,
		nc:              nc,
		runningWG:       sync.WaitGroup{},
		shutdownTimeout: 3 * time.Second,
		shutdownChan:    make(chan bool),
		handlers:        handlers,
		metrics:         metrics,
		{{if $.UseValidation -}}
		validators:      validators,
		{{- end }}
	}
	s.ctx, s.cancelFunc = context.WithCancel(ctx)
	return s
}

// Listen run listening of nats server
// nolint:gocyclo
func (s *Server) Serve() error {
	defer close(s.shutdownChan)
	{{- if $.UseValidation -}}
	if err := s.validators.check(); err != nil {
		return err
	}
	{{- end }}

	var wg sync.WaitGroup
	{{- range $index, $method := .Methods }}
	// Run listener {{ $.ServiceName }}.{{ $method.Name }}
	wg.Add(1)
	go func() {
		defer wg.Done()
		s.listenTopic("{{ $.ServiceName }}", "{{ $method.Name }}", s.{{ $method.Name }}Call)
	}()
	{{- end}}
	wg.Wait()
	if err := s.nc.LastError(); err != nil {
		s.logger.WithFields(logrus.Fields{"err": err}).Error("Last error of nats connection")
		return err
	}
	s.runningWG.Wait()
	return nil
}
{{range $method := .Methods}}
func (s *Server) {{ $method.Name }}Call(meta *coreModels.RequestMeta, data []byte) *coreModels.Response {
	var req serverHandlers.{{ $method.RequestName }}
	if err := json.Unmarshal(data, &req); err != nil {
		return coreModels.NewResponseErr("Unknown", coreErrors.New(coreErrors.CodeBadRequest, "Can't unmarshal request data", err))
	}
	l := s.logger.WithField("requestID", meta.RequestID).WithField("origin", meta.Origin)
	result, errModel := s.handlers.{{ $method.Name }}(coreCtx.NewContext(meta, l), &req)
	if errModel != nil {
		return coreModels.NewResponseErr(meta.RequestID, errModel)
	}
	respBytes, err := json.Marshal(result)
	if err != nil {
		return coreModels.NewResponseErr(meta.RequestID, coreErrors.New(coreErrors.CodeInternal, "Can't marshal response", err))
	}
	return coreModels.NewResponseOK(meta.RequestID, respBytes)
}
{{end}}
func (s *Server) Shutdown(ctx context.Context) error {
	s.cancelFunc()
	select {
	case <-time.After(s.shutdownTimeout):
		return fmt.Errorf("can't graceful shutdown, after %s", s.shutdownTimeout.String())
	case <-s.shutdownChan:
		s.logger.Info("All calls was correct finished")
	}
	return nil
}

// Reload operation implementation
func (s *Server) Reload() error {
	return fmt.Errorf("method reload not implemented")
}

// Maintenance operation implementation
func (s *Server) Maintenance() error {
	return fmt.Errorf("method reload not implemented")
}

func (s *Server) listenTopic(service string, method string, topicFunc func(meta *coreModels.RequestMeta, data []byte) *coreModels.Response) {
	topicName := fmt.Sprintf("%s.%s", service, method)
	listenChan := make(chan *nats.Msg, 1000)
	subscr, err := s.nc.QueueSubscribeSyncWithChan(
		topicName,
		topicName,
		listenChan,
	)
	if err != nil {
		s.logger.WithField("err", err).Error("Can't subscribe to subject")
	}
	s.logger.Debugf("Listen subject: '%s'", subscr.Subject)
	if err := s.nc.Flush(); err != nil {
		s.logger.WithFields(logrus.Fields{"err": err}).Error("Can't flush nats connection")
	}
	for {
		select {
		case msg := <-listenChan:
			s.runningWG.Add(1)
			go func(msg *nats.Msg) {
				s.logger.
					WithField("topic", topicName).
					WithField("data", string(msg.Data)).
					Debug("Request")
				defer func() {
					if r := recover(); r != nil {
						s.logger.WithField("topic", topicName).Errorf(
							"Panic in call for message: %+v\n panic: %+v",
							msg,
							r,
						)
					}
					s.runningWG.Done()
				}()
				s.metrics.APIDurationFunc(service, method, func() (respType coreModels.ResponseType) {
					{{if $.UseValidation -}}
					validationRequest, err := gojsonschema.Validate(
						s.validators.getLoader(method + "Request"),
						gojsonschema.NewBytesLoader(msg.Data),
					)
					if err != nil {
						return s.sendResponse(
							msg.Reply,
							topicName,
							coreModels.ResponseTypeErr,
							coreModels.NewResponseErr(
								"Unknown",
								coreErrors.New(coreErrors.CodeBadRequest, "Can't validate request", err),
							),
						)
					}
					if !validationRequest.Valid() {
						errs := make([]error, 0)
						fields := make(logrus.Fields)
						fields["topic"] = topicName
						for _, e := range validationRequest.Errors() {
							fields[e.Field()] = e.Description()
							errs = append(errs, errors.New(e.String()))
						}
						s.logger.WithFields(fields).Error("Request validation error")
						return s.sendResponse(
							msg.Reply,
							topicName,
							coreModels.ResponseTypeErr,
							coreModels.NewResponseErr(
								"Unknown",
								coreErrors.New(coreErrors.CodeBadRequest, "Can't validate request", err),
							),
						)
					}
					{{- end }}
					var req coreModels.Request
					if err := json.Unmarshal(msg.Data, &req); err != nil {
						return s.sendResponse(
							msg.Reply,
							topicName,
							coreModels.ResponseTypeErr,
							coreModels.NewResponseErr(
								"Unknown",
								coreErrors.New(coreErrors.CodeBadRequest, "Can't unmarshal request data", err),
							),
						)
					}
					resp := topicFunc(&req.Meta, req.Data)
					return s.sendResponse(
						msg.Reply,
						topicName,
						resp.Type,
						resp,
					)
				})
			}(msg)
		case <-s.ctx.Done():
			err := subscr.Unsubscribe()
			if err != nil {
				s.logger.WithField("err", err).Error("Can't unsubscribe from nats")
			}
			return
		}
	}
}

func (s *Server) sendResponse(
	replyTopic string,
	topicName string,
	responseType coreModels.ResponseType,
	response *coreModels.Response,
)coreModels.ResponseType {
	bytes, err := json.Marshal(response)
	if err != nil {
		bytes = coreModels.NewJSONMarshallErrResponseBytes(response.Meta.RequestID)
	}

	{{if $.UseValidation -}}
	validationResponse, err := gojsonschema.Validate(
	s.validators.getLoader(method + "Response"),
		gojsonschema.NewBytesLoader(respBytes),
	)
	if err != nil {
		s.logger.
			WithFields(logrus.Fields{"err": err, "topic": topicName}).
			Error("Can't validate response")
	} else if !validationResponse.Valid() {
		fields := make(logrus.Fields)
		fields["topic"] = topicName
		for _, e := range validationResponse.Errors() {
			fields[e.Field()] = e.Description()
		}
		s.logger.WithFields(fields).Error("Response validation error")
	}
	{{- end }}

	if err := s.nc.Publish(replyTopic, bytes); err != nil {
		s.logger.
			WithField("topic", topicName).
			WithField("data", string(bytes)).
			WithField("err", err).
			Errorf("Can't publish response to topic %s", replyTopic)
		return coreModels.ResponseTypeErr
	}
	s.logger.
		WithField("topic", topicName).
		WithField("data", string(bytes)).
		Debug("Response")
	return responseType
}

//======================================================================================================================

{{if $.UseValidation -}}
type Validators struct {
	list          []string
	validatorsMap map[string]gojsonschema.JSONLoader
}

func NewValidators() *Validators {
	v := &Validators{
		validatorsMap: make(map[string]gojsonschema.JSONLoader),
		list: []string{
			{{- range $method := .Methods}}
			"{{ $method.Name }}Request",
			"{{ $method.Name }}Response",
			{{- end }}
		},
	}
	return v
}
{{ range $method := .Methods}}
func (v *Validators) With{{ $method.Name }}Request(loader gojsonschema.JSONLoader) *Validators {
	v.validatorsMap["{{ $method.Name }}Request"] = loader
	return v
}

func (v *Validators) With{{ $method.Name }}Response(loader gojsonschema.JSONLoader) *Validators {
	v.validatorsMap["{{ $method.Name }}Response"] = loader
	return v
}
{{ end }}

func (v *Validators) LoadFromDir(dir string) error {
	return filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if info.IsDir() {
			return nil
		}
		fileNameArr := strings.Split(info.Name(), ".")
		if len(fileNameArr) != 4 {
			return nil
		}
		if fileNameArr[3] != "json" {
			return nil
		}
		v.validatorsMap[fileNameArr[1]+fileNameArr[2]] = gojsonschema.NewReferenceLoader("file://" + path)
		return nil
	})
}

func (v *Validators) GetLoader(loader string) gojsonschema.JSONLoader {
	return v.validatorsMap[loader]
}

func (v *Validators) Check() error {
	listNotRegistered := make([]string, 0)
	for _, loader := range v.list {
		if _, ok := v.validatorsMap[loader]; !ok {
			listNotRegistered = append(listNotRegistered, loader)
		}
	}
	if len(listNotRegistered) > 0 {
		return fmt.Errorf("you must register contracts for: %+v", listNotRegistered)
	}
	return nil
}
{{- end}}
