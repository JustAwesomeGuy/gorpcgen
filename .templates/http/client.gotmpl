// Code generated by gorpcgen; DO NOT EDIT.

package {{ .ClientPackage }}

import (
	"bytes"
	"encoding/json"
	e "errors"
	"io/ioutil"
	"net/http"
	"strconv"

	"github.com/andrskom/gorpcgen/protocol/errors"
	"github.com/andrskom/gorpcgen/protocol/models"
	serverHandlers "{{ $.HandlersPackage }}"
	"github.com/sirupsen/logrus"
)

// Client is auto generated client for service
type Client struct {
	logger *logrus.Entry
	client *http.Client
	host   string
}

// NewClient init client
func NewClient(
	logger *logrus.Entry,
	client *http.Client,
	host string,
) *Client {
	return &Client{
		logger: logger,
		client: client,
		host:   host,
	}
}
{{range $method := .Methods}}
// {{ $method.TitleName }} is public service method
func (c *Client) {{ $method.TitleName }}(
	meta models.RequestMeta,
	requestData *serverHandlers.{{ $method.RequestName }},
) (*serverHandlers.{{ $method.ResponseName }}, *errors.Error) {
	reqDataBody, err := json.Marshal(requestData)
	if err != nil {
		return nil, errors.New(errors.CodeClient, "Can't marshal request data'", err)
	}
	req := models.Request{
		Meta: meta,
		Data: json.RawMessage(reqDataBody),
	}
	respBody, errModel := c.processRequest("{{ $.ServiceName }}/{{ $method.Name }}", &req)
	if errModel != nil {
		return nil, errModel
	}
	result := &serverHandlers.{{ $method.ResponseName }}{}
	if err := json.Unmarshal(respBody, &result); err != nil {
		return nil, errors.New(errors.CodeClient, "Can't unmarshal response data", err)
	}
	return result, nil
}
{{end}}
func (c *Client) processRequest(method string, req *models.Request) ([]byte, *errors.Error) {
	reqBody, err := json.Marshal(req)
	if err != nil {
		return nil, errors.New(errors.CodeInternal, "Can't marshal request'", err)
	}
	c.logger.WithField("method", method).WithField("data", string(reqBody)).Info("Request")
	httpReq, err := http.NewRequest(http.MethodPost, c.host+method, bytes.NewReader(reqBody))
	if err != nil {
		return nil, errors.New(errors.CodeClient, "Can't create request", err)
	}
	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return nil, errors.New(errors.CodeClient, "Can't do request", err)
	}
	respBytes, err := ioutil.ReadAll(httpResp.Body)
	if err != nil {
		return nil, errors.New(errors.CodeClient, "Can't read response body", err)
	}
	if err := httpResp.Body.Close(); err != nil {
		c.logger.WithError(err).Error("Can't close response body")
	}
	c.logger.WithField("method", method).WithField("data", string(respBytes)).Info("Response")
	if httpResp.StatusCode != http.StatusOK {
		return nil, errors.New(
			errors.CodeInternal,
			"Bad response status code",
			e.New(string(respBytes)),
			e.New(strconv.Itoa(httpResp.StatusCode)),
		)
	}

	resp := models.Response{}
	if err := json.Unmarshal(respBytes, &resp); err != nil {
		return nil, errors.New(errors.CodeInternal, "Can't unmarshal response'", err)
	}
	switch resp.Type {
	case models.ResponseTypeErr:
		respErr := &errors.Error{}
		if err := json.Unmarshal([]byte(resp.Result), &respErr); err != nil {
			return nil, errors.New(errors.CodeInternal, "Can't unmarshal response error", err)
		}
		return nil, respErr
	case models.ResponseTypeOK:
		return []byte(resp.Result), nil
	default:
		return nil, errors.New(errors.CodeInternal, "Unknown type of response")
	}
}
